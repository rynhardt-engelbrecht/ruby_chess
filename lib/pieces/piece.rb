# frozen_string_literal: true

require_relative '../board'

# abstract class containing shared logic between chess pieces
class Piece
  attr_accessor :location, :moved
  attr_reader :color, :valid_moves, :symbol

  def initialize(board, location, color, moved: false)
    board.add_observer(self)

    @location = location
    @color = color
    @moved = moved
    @valid_moves = []
    @symbol = nil
  end

  def update(board)
    @valid_moves = []
    legal_moves(board, @location[0], @location[1])
  end

  def legal_moves(board, rank, file)
    generate_moves(board, rank, file)
  rescue RuntimeError => e
    puts "Error occured: #{e.message}"
  end

  def safe_moves(board)
    @valid_moves.reject do |move|
      temp_board = Marshal.load(Marshal.dump(board))
      temp_board.move_piece(location, move)
      temp_board.in_check?(color)
    end
  end

  def score_map
    puts 'Abstract method called'
  end

  def value
    puts 'Abstract method called'
  end

  private

  def traverse_move_array(board, rank_increment, file_increment, array)
    array.each do |move|
      new_rank = move[0] + rank_increment
      new_file = move[1] + file_increment

      add_move([new_rank, new_file]) if valid_move?(board, new_rank, new_file)
    end
    # traverses an array of possible moves generated by each piece's respective generate_moves method
    # and using the add_move method to sort between moves and captures.
  end

  def add_move(move)
    @valid_moves << move
    # sorts between moves and captures
  end

  def generate_moves(_board, _rank, _file)
    raise RuntimeError.new, 'Abstract method called'
    # this method should never get called
  end

  def valid_move?(board, rank, file)
    on_board?(board, rank, file) && !ally_piece?(board, rank, file)
    # this method checks whether a given move is within the bounds of the board, and that there isn't an ally piece
    # present on that square on the board.
  end

  def on_board?(board, rank, file)
    [rank, file].all? { |pos| pos.between?(0, board.data.size - 1) }
  end

  def ally_piece?(board, rank, file)
    !board.data[rank][file].nil? && board.data[rank][file].color == color
  end

  def opponent_piece?(board, rank, file)
    !board.data[rank][file].nil? && board.data[rank][file].color != color
  end
end
